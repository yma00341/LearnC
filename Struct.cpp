#include <stdio.h>
#include <stddef.h>
//offsetof(struct S,i)	结构体中某变量的偏移量,是一种宏，所以参数可以传类型

/*
设置默认对齐数为4
#pragma pack(4)
结构体创建完之后，取消设置的默认对齐数
#pragma pack()
*/


//如何计算结构体变量的大小
//*首先掌握对齐规则
//1.每一个成员放在与结构体变量偏移量为0的地址处
//2.其他成员变量要对齐到某个数字(对齐数)的整数倍的地址处
//	对齐数 = 编译器默认的一个对齐数与该成员大小的较小值
//		VS中默认的值是8
//3.结构体总大小为最大对齐数(每个成员变量都有一个对齐数)的整数倍
//4.如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处
//	结构体的整体大小就是所有最大对齐数(含嵌套结构体的对齐数)的整数倍

struct s1
{
	char c1;	//地址在s1变量开始的地方存一个字节
	int a;		//地址在s1开始的4字节处的4个字节，与c1的中间部分浪费了
	char c2;	//地址在s1的8字节处，存放一个字节
	//总大小为最大对齐数的整数倍，这里最大的就是存a的时候的4
	//所以原先的9不能使用，需要用到12
};	//大小为12


//位段 - 也算结构体的一种
/*
位指的是 二进制位
冒号后的是 决定某个变量用多少bit位表示，例如 int 4 可以用3个bit位，而没必要32位
1.位段的成员必须是int、unsigned int 或 signed int、char等
	通常一个结构体里面都是相同的类型
2.位段的成员名后面有一个冒号和一个数字
*/
struct Z
{
	int _a : 2;
	int _b : 5;
	int _c : 10;
	int _d : 30;
};
/*
Z就是一个位段类型	-	创建方法和结构体相同:struct S s;
位段的空间大小：8字节
位段开辟空间的规则：
1.位段的成员可以是 int ,unsigned int ,signed int 或者是char(属于整形家族)类型
2.位段的空间上是按照需要以4个字节(int)或者1个字节(char)的方式来开辟的
3.一次开辟使用到下一个位段不足的时候，舍弃，重开开辟另一个存储
4.位段设计很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免位段
对于S，先开辟4个字节(int)，a，b，c 总共17个bit位，剩余15个无法存放d，浪费15bit
再开辟4字节空间(int)，存放d的30bit，多余的2bit浪费
*/



//枚举
/*
本质上是一个整形类型的值
1.增加代码的可读性和可维护性
2.和#define定义的标识符相比，枚举有类型检查，更加严谨
3.防止了命名污染(封装)
4.便于调试
5.使用方便，一次可以定义多个变量
*/
enum Day
{
	Mon,//0 - 还可以通过Mon = 1，这种方法进行赋值
	Tues,//1
	Wed,//2 
	Thur,//3 
	Fri,//4
	Sat,//5
	Sun	//6
};
enum Day day = Sun;//只能拿枚举常量给枚举变量赋值才不会出现类型的差异



//联合体，共用体
/*
包含一些列的成员，特征是这些成员共用同一块空间
联合体变量的大小至少是最大成员的大小
当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍
*/
union Un
{
	char c;
	int i;
};
//sizeof = 4
//判断系统大端或者小端存储
int check_sys()
{
	int a = 1;
	//通过读取出来的低地址第一个字节是0还是1判断大小端
	//1则是小端存储，0则是大端存储
	return *(char*)&a;
}
int check_sys_()
{
	union Un
	{
		char c;
		int i;
	}u;
	u.i = 1;
	//共用存储空间，存入1之后返回char类型一个字节，0则是大端，1是小端
	return u.c;
}








int main()
{
	
	return 0;
}