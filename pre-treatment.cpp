#include <stdio.h>


/*
翻译环境
	test.exe存放的二进制信息(二进制文件)
	翻译就是把源代码转换为可执行的可执行的二进制指令

编译：每一个源文件都会作为一个单独的单元，交给编译器单独进行处理，生产对于的目标文件(.ojb文件)
链接：所有的目标文件经过链接器的处理成为可执行程序
		链接器同事也会引入标准C的函数库中任何被该程序所用到的函数，而且他可以搜索程序员个人的
		程序库，将其需要的函数也链接到程序中

1.编译器
	预编译 -> 编译 -> 汇编
	
	预编译 - 生成.i文件			gcc -E test.c
		1.#include
			头文件的包括
		2.注释删除
			使用空格来代替注释
		3.#define预处理指令
			定义符号的替换
	编译 - 生成.s文件			gcc -S test.i
		把C语言代码翻译成汇编代码
		1.语法分析
		2.词法分析
		3.语义分析
		4.符号汇总
	汇编 - 生成可重定位目标文件的.o文件
		把汇编代码转换成为二进制指令
		1.形成符号表 -> 一张标志既放符号，也会放符号对应的地址
		2.汇编指令 -> 二进制指令 ------->test.o

2.链接器
	1.合并段表 -> .o文件会按照elf格式把自己固定分成几个段，不同文件内容不同，但是格式相同
					对应段的数据按照一定规则合并在一起，生成一个可执行程序，也是elf格式
	2.符号表的合并和重定义 -> 相同的符号使用有效的地址，比如单纯用来声明的符号，会忽略
							  而使用能确切定义函数的地址


运行环境
1.程序必须载入内存中，在有操作系统的环境中，一般这个操作由操作系统来完成
	在独立的环境中，程序的载入必须手动安排，也可能是通过可执行代码置入只读内存来完成
2.程序的执行便开始，接着便调用main函数
3.开始执行程序代码，这个时候程序将使用一个运行时堆栈(stack)，存储函数的局部变量和返回地址
	程序同时也可以使用静态(static)内存，存储于静态内存中的变量在程序的整个执行过程一直保留他们的值
4.终止程序，正常终止main函数，也可能是意外终止
*/


/*
预处理(预编译)详解
预定义符号
__FILE__	//进行编译的源文件,打印出来就是文件的完全路径
__LINE__	//文件当前的行号，打印出来对应这条输出指令的行数
__DATE__	//文件被编译的日期，代码执行的日期
__TIME__	//文件被编译的时间，代码执行的时间
__STDC__	//如果编译器遵循ANSI C，其值为1，否则就是未定义
//例如写入日志文件
FILE* pf = fopen("log.txt","w");
fprintf(pf,"file:%s line:%d date:%s time:%s",__FILE__,__LINE__,__DATE__,__TIME__)

预处理指令
1.#define		//定义标识符、宏
		
		#define do_foever for(;;)		//实现死循环
		#define CASE break;case			//在写case语句的时候自动把break加上
		//如果定义的stuff过长，可以分行写，但是除了最后一行外，前面每一行后面都加上\(续行)
		#define DEBUG_PRINT printf("file:%s line:%d	\
									date:%s time:%s",\
									__FILE__,__LINE__,   \
									__DATE__,__TIME__)

宏是完成替换的而不是传参的
	例如 #define mul(X) X*X
	mul(5+1) //结果为11，因为替换之后，算的是 5+1*5+1 == 11
	所以宏替换不要吝啬括号
	1.调用宏的时候，首先对参数进行检查，是否有define定义的，先完成逐个替换
	2.替换后参数名被值替换
	3.对结果文件进行扫描，重复1-2的步骤
	4.宏参数可以出现define定义的符号，但是不能递归
	5.字符串出现的define定义符号并不会被替换



#和##符号
	1.#
	#define PRINT(X) printf("the value of" #X "is %d\n",X)
	//PRINT(A) ，传入A的时候，#X会被当成"A"字符串A处理，即实现把参数插入到字符串中
	2.##
	##可以把位于它两端的符号合成一个符号
	#define CAT(X,Y) X##Y
	int Class84 = 2019;
	printf("%d\n",CAT(Class,84));	//结果为2019，因为预处理会吧Class和84连在一起变为Class84，即2019


带副作用的宏参数
	#define MAX(X,Y) (X)>(Y)?(X):(Y)
	int a = 10;
	int b = 11;
	int max = MAX(a++,b++);
	printf("%d %d %d\n",max,a,b);	//12 11 13
	//宏参数带有副作用，因为宏是替换而不是计算好再传的，所以a++传入X，b++传入Y
	//(a++)>(b++)?(a++):(b++)	先执行前面的比较(a++)>(b++)，都是先使用结果再++，10>11结果为假，所以执行b++
	//但是判断之后，a和b已经++过了，所以a=11，b=12
	//之后，(a++):(b++)语句执行的时候，使用的是b++，所以先把b的结果给MAX = 12，之后++
	//最终整个MAX传参函数代码执行结束，a++执行了一次，b++执行了两次，a =11，b = 13


//宏和函数
	优势：
	宏在预处理阶段就完成了，没有函数的调用和返回的开销
	函数必须声明类型，只能在类型合适的表达式使用，宏则是类型无关的，只要能用>符号表示这种
	劣势:
	每次使用宏，宏定义的代码将插入程序中，除非宏比较短，否则可能大幅度增加程序长度
	宏是没法调试的
	宏由于类型无关，不够严谨
	宏可能会带来运算符优先级的问题容易出错

	宏有时候能做到函数做不到的事情(比如传递类型)
	#define MALLOC(num,type) (type*)malloc(num*sizeof(type));	//把数据的类型传入宏

2.#undef	- 移除一个宏定义
	#undef MAX

3.命令行定义 - gcc -D ARRAY_SIZE=10 programe.c
		linus系统

4.条件编译 - 使用时候和if语句相似，并且可以类比if语句进行嵌套使用
	#if
		//如果DEBUG定义过，就执行代码
	#elif
	#else
	#endif

	#if defined(symbol)
	#ifdef symbol
	//上两句相同，使用方法和#if相同，结尾#endif

	#if !defined(symbol)
	#ifndef symbol
	//不定义的情况下执行代码


5.文件包括
	#include <>
	#include ""
	//如果包含的本地文件就用"",库文件用<>
	//""查找策略是先在源文件目录下查找，如果未找到，就向查找库函数头文件一样在标准位置查找
	//<>库文件是直接去标准路径下去查找，虽然可以也是用""的方式，但是效率低
	//解决头文件重复包含的问题
		#pragma once 或者 #ifndef __TEST_H__
						  #define __TEST_H__
								//执行代码
						  #endif

#pragma pack(4)	//默认对齐数的设置

#line
*/


#include <stddef.h>
//自己实现
#define OFFSETOF(struct_name,member_name) (int)&(((struct_name*)0)->member_name)
//把0强制转换成结构体类型的指针并赋值地址为0，指向其中的成员
//因为起始地址是0，所以不必要地址相减
//编写宏实现结构体某变量的偏移量
//offsetof(struct S,n);
struct S
{
	char a;
	char b;
	int c;
};
int main()
{
	printf("%d\n",OFFSETOF(struct S, c));
	return 0;
}