#include <stdio.h>

//int main()
//{
//	//整数的二进制表示分为：原码，反码，补码
//	//正数的原码，反码，补码相同
//	//负数的原码符号位为1，除了符号位按位取反为反码，反码加一为补码
//	//	/和%，取余操作的操作符左右不能有浮点类型
//	int a = 16;
//	int b = -1;
//	//右移操作符	分为算数和逻辑右移，算数是左边补原符号位右边抛弃，逻辑是左边补0右边抛弃
//	//左移操作符	左边抛弃，右边都补0
//	int c = a >> 1;
//	int d = b >> 1;
//	//a		00000000 00000000 00000000 00010000		a为正数
//	//c		00000000 00000000 00000000 00001000		右移左边补原符号位0
//	//b		10000000 00000000 00000000 00000001		原码
//	//b		11111111 11111111 11111111 11111110		反码
//	//b		11111111 11111111 11111111 11111111		补码
//	//d		11111111 11111111 11111111 11111111		d的存储形式	b右移补原符号位1
//	//d		11111111 11111111 11111111 11111110		d的补码减一得到反码
//	//d		10000000 00000000 00000000 00000001		反码除符号位按位取反得到原码	-1	
//	printf("%d\n", c);	//8
//	printf("%d\n", d);	//-1
//
//
//	return 0;
//}


//
//int main()
//{
//	//位操作符	
//	//& - 按位与	同为1为1，其余为0
//	int a = 3;
//	int b = 5;
//	int c = a&b;	//结果为1
//	//a		00000000 00000000 00000000 00000011
//	//b		00000000 00000000 00000000 00000101
//	//c		00000000 00000000 00000000 00000001
//	//如果是负数要按照补码计算
//	int d = a | b;	//结果为7
//	//| - 按位或	同为0为0，其余为1
//	//d		00000000 00000000 00000000 00000111
//	int e = a^b;	//结果为6
//	//^ - 按位异或	对应二进制位相同为0，不同为1
//	//e		00000000 00000000 00000000 00000110
//	printf("%d %d %d\n", c, d, e);
//
//	return 0;
//	
//}



//交换两格变量的值且不能使用第三个变量
//int main()
//{
//	//1.异或法
//	int a = 3;	//011
//	int b = 5;	//101
//	a = a^b;	//110
//	b = a^b;	//011	为3	
//	a = a^b;	//101	为5
//	printf("%d %d\n", a, b);
//
//
//	//2.加减法,缺陷是相加可能会发生溢出，超过int类型的限制
//	//a = a + b;
//	//b = a - b;
//	//a = a - b;
//	//printf("%d %d\n", a, b);
//	return 0;
//
//}



//求一个正数在内存中1的个数
//int main()
//{
//	//1.类短除法，弊端是不能输入负数
//	int num;
//	int i;
//	int count = 0;
//	scanf("%d", &num);
//	//while (num)
//	//{
//	//	if (num % 2 == 1)
//	//	{
//	//		count++;
//	//	}
//	//	num /= 2;
//	//}
//
//	//2.利用按位与操作符 &
//	//整形有32个bit位，按位与1结果为0，证明最后一位是0，为1证明最后一位是1
//	//结果出来后右移
//	//for (i = 0; i < 32; i++)
//	//{
//	//	if (1 == ((num >> i) & 1))
//	//		count++;
//	//}
//
//	//3.优化方案，2中需要循环固定32次
//	while (num)
//	{
//		count++;
//		num = num&(num - 1);
//		//假设输入10
//		//10	00000000 00000000 00000000 00001010
//		//9		00000000 00000000 00000000 00001001
//		//相与的结果为	1000	即8，下一次即8和7相与，结果为0，循环两次
//		//此方法大幅度减小了循环次数
//		//最高为-1的32次
//	}
//
//	printf("%d\n",count);	//输入-1结果为32
//	
//
//	return 0;
//}


//单目运算符
//!	逻辑反操作
//-	负值
//+	正值
//&	取地址
//sizeof	操作数的类型长度
//~		对一个数的二进制按位取反
//--	前置先对数进行运算，再使用这个数；后置先使用这个数再进行运算
//++
//*		间接访问操作符(解引用)
//(数据类型)		强制类型转换

//0按位取反的结果为-1
//00000000 00000000 00000000 00000000
//11111111 11111111 11111111 11111111	按位取反之后电脑存的补码
//11111111 11111111 11111111 11111110	符号位为1，负数的存储形式，补码减一
//10000000 00000000 00000000 00000001	除了符号位按位取反，得到原码-1


//int main()
//{
//	//想要二进制的某个数的某一位变成1
//	int a = 11;		//00000000 00000000 00000000 00001011
//	//想要第三位变成1
//	int b = a | (1 << 2);	//a | (00000000 00000000 00000000 00000100)	结果为15
//	//如果想要第三位变回0
//	int c = a & (~(1 << 2));	//a | (~(00000000 00000000 00000000 00000100))
//								//即a | (11111111 11111111 11111111 11111011)	结果为11
//	printf("%d %d ", b, c);
//
//	return 0;
//}




//逻辑运算符	返回值为真或者假
//&&		逻辑与	左右都为真才为真，其余为假
//||		逻辑或	左右都为假才为假，其余为真
//int main()
//{
//	int  i = 0, a = 0, b = 2, c = 3, d = 4;
//	i = a++ && ++b && d++;
//	//a++先使用0，所以a++结果为0，逻辑与操作结果为0，只算左边，右边不进行计算
//	//所以最终只有a++执行过一次，a的值变为1
//	//结果为 1 2 3 4 0
//
//	//如果a改为1
//	//int  i = 0, a = 1, b = 2, c = 3, d = 4;
//	//i = a++ && ++b && d++;
//	//结果为2 3 3 5 1
//
//	//如果改为||
//	//int  i = 0, a = 0, b = 2, c = 3, d = 4;
//	//i = a++ || ++b || d++;
//	//结果为 1 3 3 4 1
//	printf("a = %d\nb = %d\nc = %d\nd = %d\ni = %d\n", a, b, c, d, i);
//
//	return 0;
//}



//条件操作符 (三目操作符)
//表达式1 ? 表达式2 : 表达式3
//如果表达式1的结果为真，执行表达式2的结果，否则表达式3的结果
//int main()
//{
//	int a = 1;
//	int b = 2;
//	printf("%s\n", a > b ? "男" : "女");
//	return 0;
//}



//逗号表达式
//从左往右执行，只有最后一个会产生结果作用
//[]操作符有两个操作数，一个是数组名还有一个是下标
//()函数调用操作符



//整形提升，一般的CPU
//表达式中各种长度可能小于int型的变量都要转换为int型或者unsigned int型进行计算
//int main()
//{
//	char a = 3;
//	//00000000 00000000 00000000 00000011
//	//char只能存一个字节，所以a里面存放00000011
//	char b = 127;
//	//00000000 00000000 00000000 01111111
//	//同理，截断存放 01111111
//	char c = a + b;
//	//隐式类型转换，计算的时候按照变量的符号位来提升，成为普通的整形
//	//即		a	00000000 00000000 00000000 00000011		char类型的a的符号位为0
//	//同理		b	00000000 00000000 00000000 01111111
//	//得到结果为	00000000 00000000 00000000 10000010
//	//结果保存你到c，c也是char类型，所以截断，得到10000010
//	//当打印结果要求是整形时候，也要发生整形提升
//	//按照c的符号位全部补1，以补码的形式存储，c的补码 11111111 11111111 11111111 10000010
//	//按照c的反码得到原码	10000000 00000000 00000000 01111110	即-126
//	printf("%d\n", c);	//结果为-126
//	return 0;
//}
//int main()
//{
//	char a = 0xb6;		//10110110		整形提升的时候前面补1，打印不了		
//	short b = 0xb600;	//同a
//	int c = 0xb6000000;
//	if (a == 0xb6)
//		printf("a\n");
//	if (b == 0xb600)
//		printf("b\n");
//	if (c == 0xb6000000)
//		printf("c\n");
//
//	return 0;
//}